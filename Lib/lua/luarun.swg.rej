diff a/Lib/lua/luarun.swg b/Lib/lua/luarun.swg	(rejected hunks)
@@ -110,6 +110,7 @@ typedef struct {
   lua_CFunction   setmethod;
 } swig_lua_attribute;
 
+
 typedef struct swig_lua_class {
   const char    *name;
   swig_type_info   **type;
@@ -117,6 +118,7 @@ typedef struct swig_lua_class {
   void    (*destructor)(void *);
   swig_lua_method   *methods;
   swig_lua_attribute     *attributes;
+  swig_lua_const_info    *class_constants;
   struct swig_lua_class **bases;
   const char **base_names;
 } swig_lua_class;
@@ -425,6 +427,19 @@ SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
     return 1;
   }
   lua_pop(L,1);  /* remove whatever was there */
+  /* ok, so try the .enum table */
+  SWIG_Lua_get_table(L,".enum"); /* find the .enum table */
+  assert(lua_istable(L,-1));  /* just in case */
+  lua_pushvalue(L,2);  /* key */
+  lua_rawget(L,-2);  /* look for the fn */
+  lua_remove(L,-2); /* stack tidy, remove .enum table */
+  if( !lua_isnil( L, -1 ) ) {
+    assert( !lua_isfunction(L,-1) ); // it MUST NOT be a function.
+    lua_remove(L,-2); /* stack tidy, remove metatable */
+    return 1;
+  }
+  lua_pop(L,1);  /* remove whatever was there */
+
   /* NEW: looks for the __getitem() fn
   this is a user provided get fn */
   SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
@@ -540,6 +555,24 @@ SWIGINTERN int  SWIG_Lua_class_disown(lua_State* L)
   return 0;
 }
 
+/* Constructor proxy. Used when class name entry in module is not class constructor,
+but special table instead */
+SWIGINTERN int SWIG_Lua_constructor_proxy(lua_State* L)
+{
+  /* unlimited number of parameters
+     First one is our proxy table and we should remove it
+     Other we should pass to real constructor
+   */
+   assert(lua_istable(L,1));
+   lua_pushstring(L,".constructor");
+   lua_rawget(L,1);
+   assert(!lua_isnil(L,-1));
+   lua_copy(L,-1,1); /* replace our table with real constructor */
+   lua_pop(L,1);
+   lua_call(L,lua_gettop(L)-1,1);
+   return 1;
+}
+
 /* gets the swig class registry (or creates it) */
 SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
 {
@@ -567,6 +600,42 @@ SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
   lua_remove(L,-2);    /* tidy up (remove registry) */
 }
 
+SWIGINTERN void SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]); // forward declaration
+
+/* helper recursively add class constants */
+SWIGINTERN void SWIG_Lua_add_class_constants(lua_State* L, swig_lua_class* clss)
+{
+  /* call all the base classes first: we can then override these later: */
+  for(int i=0;clss->bases[i];i++)
+  {
+    SWIG_Lua_add_class_constants(L,clss->bases[i]);
+  }
+  SWIG_Lua_InstallConstants( L, clss->class_constants );
+}
+
+/* helper create class name registry in module. E.g. for clas MyClass creates
+a table-functor so you can do MyClass(...) (and that is equal to new_MyClass) to create new
+objects as well as do MyClass.EnumValue1 to access enum values */
+SWIGINTERN void SWIG_Lua_add_class_name_registry_entry(lua_State* L, swig_lua_class* clss)
+{
+  lua_checkstack(L,5); /* just in case */
+  assert(lua_istable(L,-1));  /* just in case */
+  lua_pushstring(L, clss->name);
+  lua_newtable(L); /* actual table - name registry entry */
+  if (clss->constructor)
+  {
+    SWIG_Lua_add_function(L,".constructor", clss->constructor);
+    lua_newtable(L); /* metatable for entry */
+    SWIG_Lua_add_function(L,"__call", SWIG_Lua_constructor_proxy );
+    lua_setmetatable(L,-2);
+  }
+  assert(lua_istable(L,-1)); /* just in case */
+  SWIG_Lua_add_class_constants(L,clss);
+  /* assign entry */
+  lua_rawset(L,-3);
+  /* clear stack */
+}
+
 /* helper add a variable to a registered class */
 SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
 {
@@ -584,6 +653,7 @@ SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_C
   }
 }
 
+
 /* helper to recursively add class details (attributes & operations) */
 SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
 {
@@ -597,6 +667,13 @@ SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
   for(i=0;clss->attributes[i].name;i++){
     SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
   }
+  /* add class constants */
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_get_table(L,".enum");
+  assert(lua_istable(L,-1));  /* just in case */
+  SWIG_Lua_InstallConstants( L, clss->class_constants );
+  lua_pop(L,1);
+
   /* add methods to the metatable */
   SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
   assert(lua_istable(L,-1));  /* just in case */
@@ -640,12 +717,16 @@ SWIGINTERN void SWIG_Lua_init_base_class(lua_State* L,swig_lua_class* clss)
 /* performs the entire class registration process */
 SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
 {
+#ifndef SWIG_LUA_CLASSENUM
   /*  add its constructor to module with the name of the class
   so you can do MyClass(...) as well as new_MyClass(...)
   BUT only if a constructor is defined
   (this overcomes the problem of pure virtual classes without constructors)*/
-  if (clss->constructor)
+  if (clss->constructor) // TODO:REMOVE
     SWIG_Lua_add_function(L,clss->name,clss->constructor);
+#else
+  SWIG_Lua_add_class_name_registry_entry(L,clss);
+#endif
 
   SWIG_Lua_get_class_registry(L);  /* get the registry */
   lua_pushstring(L,clss->name);  /* get the name */
@@ -662,6 +743,10 @@ SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
   lua_pushstring(L,".set");
   lua_newtable(L);
   lua_rawset(L,-3);
+  /* add a table called ".enum" */
+  lua_pushstring(L,".enum");
+  lua_newtable(L);
+  lua_rawset(L,-3);
   /* add a table called ".fn" */
   lua_pushstring(L,".fn");
   lua_newtable(L);
